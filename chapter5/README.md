# 5장 제네릭

*** 

# item26. 로타입(raw type)은 사용하지 말라
* raw type : 제네릭 타입(제네릭 클래스 or 제네릭 인터페이스)에서 타입 매개변수를 전혀 사용하지 않을 때 
ex) List<E> 의 raw type = List 
  <br />
  raw type은 제네릭 타입 정보가 전부 지워진 것처럼 동작 (제네릭이 도래하기 전의 코드와 호환되기 위해)
  <br />
  
* 제네릭 타입은 오류를 컴파일 단계에서 발견할 수 있도록 도와줌, 해당 타입 매개 변수에 엉뚱한 인스턴스를 넣을 때 컴파일 에러 발생 
<br />
  
* raw type을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다. 
<br />
  
* 그렇다면 raw type은 왜 있는 것인지 ? "호환성"
<br />


List (X) - 타입 안정성을 잃음 <br /> 
List<Object> (O) - 모든 타입을 허용한다는 의사를 컴파일러에 전달하기 때문


* 제네릭 타입을 쓰고 싶지만, 실제 타입 매개변수가 무엇인지 신경쓰고 싶지 않다면 -> ?(비한정적 와일드 카드 타입?)

* 예외
  1) class 리터럴에는 raw type 사용해야함 
    <br />
ex) List.class, String[] class, int.class (O)
  List<String>.class, List<?>.class (X)
     <br />
     
    2) instanceof 연산자
    <br />
    ex)
       <code>
       if (o instanceof Set) { Set<?> s = (Set<?>) o; }
       </code>
       
***
# item27. 비검사 경고를 제거하라 

* 비검사 경고(warning: [unchecked])는 최선을 다해서 제거해야한다. <br /> 
만약, 경고를 없앨 방법을 찾지 못하겠다면, 그 코드가 타입 안전함을 증명하고 
  > @SuppreddWarnings("unchecked")
  
  annotation으로 경고를 숨기고, 근거를 주석으로 남길 것 

***
# item 28. 배열보다는 리스트를 사용하라

### 배열과 제네릭 타입의 차이점 
1. 배열은 공변(다형성 보장), 제네릭은 불공변(타입 안정성)

- 배열 <br />
<pre>
<code>
Object objectArray = new Long[1]; // 컴파일이 된다, Long은 Object의 하위라 배열의 타입도 하위 호환됨
objectArray = 'hello';            // 런타임에서 ArrayStoreException을 던짐 
</code>
</pre>

- 리스트 <br />
<pre>
<code>
List(Object) ol = ArrayList(Long)(); // 호환되지 않아 컴파일에서부터 에러 
</code>
</pre>

2. 배열은 실체화, 제네릭은 소거 

=> 배열은 런타임에도 자신의 원소의 타입을 인지, 확인 <br />
제네릭은 런타입에 타입정보 소거, 컴파일시에만 검사 <br />
선언된 타입에 다른 타입을 넣으려 할 때, 배열은 런타임 시에, 제네릭은 컴파일 시에 에러가 나기 때문에 조금 더 안전

### 실체화 불가 타입에 대한 배열 생성은 불가 
new List<E>[], new List<String>[], new E[] (런타임에 정보가 없어지는 타입들)
배열이라 런타임에 에러를 뱉어야 하는데, 타입에 대한 정보 실체가 없는 실체화 불가 타입은 배열 생성이 불가해야함 
=> 제네릭 배열 생성 오류 

제네릭 배열이 가능하다고 가정하면 런타임에 ClassCastException 발생할 수 있는데, 이는 컴파일 타임에
타입 에러를 체크하겠다는 제네릭의 취지에 어긋남 

둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 배열을 리스트로 대체하자 

***
# item 29. 이왕이면 제네릭 타입으로 만들라

- Stack등 유틸리티 클래스를 만들 때는 제네릭 타입으로 만드는 것이 좋다


***
# item 30. 이왕이면 제네릭 타입으로 만들라


***
# item 31. 한정적 와일드카드를 사용해 API 유연성을 높이라 

*** 
# 질문 정리 

### 자바가 리스트를 기본 타입으로 제공하지 않으므로 ArrayList 같은 제네릭 타입도 기본 타입인 배열을 사용해 구현해야 한다.
=>
자바가 리스트를 기본 타입으로(기본 자료형으로) 제공하지 않으므로 내부에서 배열을 사용하여 구현해서 사용하고 있음을 의미하는 것으로 이해하였습니다.
<pre>
<code>
/**
 * Constructs an empty list with the specified initial capacity.
 *
 * @param  initialCapacity  the initial capacity of the list
 * @throws IllegalArgumentException if the specified initial capacity
 *         is negative
 */
public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    }
}


/**
 * Constructs a list containing the elements of the specified
 * collection, in the order they are returned by the collection's
 * iterator.
 *
 * @param c the collection whose elements are to be placed into this list
 * @throws NullPointerException if the specified collection is null
 */
public ArrayList(Collection<? extends E> c) { // 한정적 와일드 카드 타입 
    Object[] a = c.toArray(); // 매개변수로 받은 c를 toArray메소드를 통해 배열로 변환
    if ((size = a.length) != 0) {
        if (c.getClass() == ArrayList.class) {
            elementData = a;
        } else {
            elementData = Arrays.copyOf(a, size, Object[].class);
        }
    } else {
        // replace with empty array.
        elementData = EMPTY_ELEMENTDATA;
    }
}
</code>
</pre>

### HashMap 같은 제네릭 타입은 성능을 높일 목적으로 배열을 사용하기도 한다.
=> Hash는 내부적으로 배열을 사용함. 배열은 인덱스를 사용하여 자료의 검색이 한번에 이루어지기 때문에
검색 속도가 빠르며, 이 때문에 성능을 높일 목적으로 해쉬에서 배열을 사용하였고, 
HashMap은 내부적으로 Hashing을 이용하여 구현한 컬렉션이기 때문에 많은 양의 데이터를 검색하는데 있어 검색 속도가 빠르기 위해서
(성능을 높일 목적으로) hashing에서 배열을 사용한 것을 이야기한 것 같습니다. 


### 공통. 제네릭 타입 소거 에 대해 복습하는 시간을 가졌으면 좋겠습니다
컴파일 타임에만 타입 제약 조건을 정의하고, 런타임에는 타입을 제거
T 와 같이 타입을 직접 명시하지 않은 타입 매개 변수 - raw 타입,
1) raw타입은 컴파일 시에 Object로 대체된다
2) Object로 대체한 후 필요시에 casting
3) 타입안정성을 위해 Bridge Method를 만들 수도 있다
<pre>
<code>
public class IntegerStack extends Stack<Integer> {
   public Integer push(Integer value) {
    super.push(value);
    return value;
   }
}

public class IntegerStack extends Stack {
// Bridge method generated by the compiler

    public Integer push(Object value) {
        return push((Integer) value);
    }

    public Integer push(Integer value) {
        return super.push(value);
    }
}
</code>
</pre>
### 메서드도 형변환 없이 사용할 수 있는 편이 더 좋다 -> 막연하게 이해되나 이렇게 사용해야하는 이유와 어떤 상황에서 쓰면 좋을까요?

### 목표 타입과 목표 타입 추론은 뭘까요?
목표 타이핑 -
long Z = int * int;
=> long 자료형의 변수 Z가 int*int의 결과값을 대입한다는 의미다
계산식의 결과 자료형이 long형이기 때문에 컴파일러가
int * int식을 long* long으로 자동 변환하여 연산을
수행하는 기능을 목표 타이핑이라 한다.
결과 자료형에 따라 계산식을 자동 변환하여 연산을 수행하는 기능이 타겟 타이핑.
하단 설명에 자바 튜토리얼 설명 페이지 들어가면 
https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-typing 로, 람다표현식 화면이 나오는데, 이는 '자바 8 람다식은
함수형 프로그램을 지원하기 위해 람다식을 전달받은
메서드에 선언된 제네릭 타입으로 컴파일러가 오버로딩된 메서드의 호출을
결정하는 타겟 타이핑을 지원한다'는 설명을 위한 것 같음

목표 타입 추론 -

### p. 187 ~ 188의 comparable<E>, Delayed, ScheduledFuture<V>의 관계에 대한 설명

### (아이템30) 메서드 선언에서 타입 매개변수 목록은 '이 메서드에서는 이러한 타입 매개변수만을 사용한다'고 선언하는 용도로 이해하면 되는 건가요?

### (아이템31, p.189 예시) 와일드카드를 사용했는데, 만약 복잡한 내부 로직을 구현해야 한다면 결국 특정 제네릭으로 바꿔서 구현해야 한다는 의미인가요?

### (공통) 타입 매개변수가 구체적으로 무엇이 있고 각각의 용도가 무엇인지 모르겠어요